{"relevantArticles":[{"articleTitle":"自动清理日志 Shell 脚本","articleAbstractText":"以删除 Jetty 日志为例，仅保留最近 7 天的日志文件。","articleStatus":0,"articlePermalink":"/autoremove-logs","articleImg1URL":"https://img.hacpai.com/bing/20171127.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Linux 内核网络参数","articleAbstractText":"Linux 系统调优时需要进行关注的内核网络参数。","articleStatus":0,"articlePermalink":"/linux-kernel-network-turning","articleImg1URL":"https://img.hacpai.com/bing/20190124.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"CLOSE_WAIT 问题分析","articleAbstractText":"问题场景 服务器出现大量 TCP 连接状态为 CLOSE_WAIT，将系统资源耗尽，导致业务处理失败。 ## 处理方式 重启导致问题的进程，释放 TCP 连接后服务恢复正常。 调整服务器网络参数： * net.ipv4.tcp_keepalive_time=600，tcp 连接空闲 10 分钟后发送探测包，默认是 7200 秒（两小时） * net.ipv4.tcp_keepalive_intvl=15，每次探测包间隔 15 秒，默认是 75 秒 * net.ipv4.tcp_keepalive_probes=5，一共发送 5 次探测包，默认是 9 次 让内核尽快检测出空闲连接并释放。 ## 分析 服务器环境是 Java、Tomcat。服务端在收到客户端 FIN 包后进入 CLOSE_WAIT，但服务端没有发送 FIN 包，具体原因没有查明。猜测的原因是 * 服务端的业务处理阻塞，导致发送不了 FIN 包 * 网络问题导致依赖的基础库 bug 附：TCP 连接状态图 ![8b538e707e964084a2161844efb023ea-tcp.jp....","articleStatus":0,"articlePermalink":"/articles/2016/10/31/1477912575623.html","articleImg1URL":"https://img.hacpai.com/bing/20181102.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"系统健康状态管理设计思路","articleAbstractText":"系统健康状态管理设计思路。","articleStatus":0,"articlePermalink":"/articles/2014/05/06/1399365922113.html","articleImg1URL":"https://img.hacpai.com/bing/20180331.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"使用 Golang 操作 Linux Namespaces","articleAbstractText":"Linux Namespaces（Linux 命名空间）机制提供了进程使用操作系统资源时的隔离方式，是基于内核实现轻量级虚拟化（容器化，例如 docker）的实现基础。 具体来说就是当我们创建一个进程时，可以给进程设置 flag 组合来构建进程的命名空间，处于不同命名空间的进程是相互隔离的。","articleStatus":0,"articlePermalink":"/golang-linux-namespaces","articleImg1URL":"https://img.hacpai.com/bing/20180909.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"MySQL 迁移 utf8 到 utf8mb4","articleAbstractText":"MySQL 版本和驱动 MySQL 至少是 5.5.3+mysql-connector-java 至少是 5.1.13，修改连接串参数 characterEncoding=UTF-8 历史数据迁移 生成表字符迁移 SQL： SELECT CONCAT( 'ALTER TABLE ', TABLE_NAME, ' CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;' ) AS mySQL FROM INFORMATION_SCHEMA. TABLES WHERE TABLE_SCHEMA = 'your_schema' 生成后执行一把，这样表和列的字符集就改完了。我这里通过修改表的字符集就自动修改列的了，最好自己确认下列是否已经改对。 修改库字符集： ALTER DATABASE your_schema CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci; 上面示例代码中的 COLLATE（排序规则）请按需修改。 关于连接串参数 characterEn....","articleStatus":0,"articlePermalink":"/articles/2018/03/15/1521094110639.html","articleImg1URL":"https://img.hacpai.com/bing/20171225.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Golang MySQL LOAD DATA LOCAL INFILE 使用","articleAbstractText":"在往 MySQL 写入大量数据时直接 insert 效率太低，应该使用 MySQL 的 LOAD DATA LOCAL INFILE。","articleStatus":0,"articlePermalink":"/golang-mysql-LOAD-DATA-LOCAL-INFILE","articleImg1URL":"https://img.hacpai.com/bing/20180303.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}