{"relevantArticles":[{"articleTitle":"敏感数据处理","articleAbstractText":"背景 大多数应用或多或少都会涉及到敏感数据处理，比如用户的手机号、身份证号，甚至银行卡账号。作为应用的开发者，如何 安全地 维护这些敏感数据呢？ 这里讨论的安全不是指服务器如何保护，而是在数据库层面做敏感数据的分离： * 业务库中不保存敏感数据，只保存混淆过的数据，比如电话字段保存的是 133****9961，在数据层面就进行脱敏 * 敏感数据统一保存在另一个库中，有应用调用一个服务来建立原值和混淆值的映射关系 * 业务库中因为保存的是脱敏过的数据，通过只读复制镜像可以很方便地提供给其他服务使用，比如 OLAP * 除了技术开发上方便，运维上也方便了很多，降低了敏感数据被暴露到外部的可能性 ### 技术设计 提供服务接口给应用存取敏感数据，本质上是一个 KV 存取服务。  一些细节： * 表 protyle 的 domain 字段用于标识该记录的作用域，在一个作用域上相同的值要保证唯一 * 表 protyle 的 ha....","articleStatus":0,"articlePermalink":"/articles/2016/05/11/1462956775250.html","articleImg1URL":"https://img.hacpai.com/bing/20180617.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"标签服务实现漫谈","articleAbstractText":"标签服务是一个较为通用的基础业务服务，比如博客系统对文章加标签、社交网络中为好友添加印象、收藏的歌曲贴标签方便整理等等。 其主要提供两类接口： 标签实体的管理/查询：负责标签实体的 CRUD 标签关联的管理/查询：将外部业务实体与标签建立/删除关联，根据外部业务实体 id 查询标签集 RDB 实现 基于关系型数据库的实现是最容易的，并且上大多数应用也是这样做的。 建立 tag 表，其中包含了 tag 的基础属性，例如 name、description 等 建立 tag_rel 关联表，其中主要包含了 object_id、tag_id 管理服务（创建/更新/删除）的实现非常容易；根据 object_id 查询其对应的标签集也很容易实现： SELECT tag_rel.tag_id, tag_rel.object_id, tag.name FROM tag_rel LEFT JOIN tag ON tag_rel.tag_id = tag.tag_id WHERE tag_rel.object_id = '2db775c1d2174a8c67fc39b86c3fc168' 问题 ....","articleStatus":0,"articlePermalink":"/articles/2015/12/01/1448958541321.html","articleImg1URL":"https://img.hacpai.com/bing/20180321.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Cobar 概述","articleAbstractText":"Cobar&nbsp;是由 Alibaba 开源的 MySQL 分布式处理中间件，它可以在分布式的环境下看上去像传统数据库一样提供海量数据服务。","articleStatus":0,"articlePermalink":"/alibaba-cobar-survey","articleImg1URL":"https://img.hacpai.com/bing/20180614.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"呼叫中心架构设计","articleAbstractText":"从呼叫模式上看，目前业界大多数采用的是\u201c回拨\u201d模式，即由呼叫中心发起两路呼叫，然后将两路进行连通。","articleStatus":0,"articlePermalink":"/articles/2016/07/24/1469349167953.html","articleImg1URL":"https://img.hacpai.com/bing/20180412.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"理解 Eureka 的 P2P 通讯","articleAbstractText":"Eureka 客户端会和在同一个可用区（Zone）的服务端进行通讯，如果通讯失败或者服务端没有和客户端在一个可用区，则客户端将进行失效转移：对其他可用区的服务端发起通讯。 服务端接收到客户端信息后，会进行一些列操作将信息同步给其他服务端节点。如果某步操作失败，信息将在下一次心跳时同步给其他服务端节点。 当一个 Eureka 服务端节点启动后，它将向其他服务端节点获取所有实例的注册信息。服务端获取到实例列表后将根据信息创建续约（renew）相关数据并准备接收来自客户端的续约请求。如果在某个时刻客户端续约失败（15 分钟内低于 85%），服务端将停止实例过期防止该实例注册信息丢失。 在 Netflix 内部，上述过程称作自我保护模式，是 Eureka 客户端和服务端通讯时发生断网的一个保护机制。在这个场景下，服务端将尝试保存住已有的注册信息。此时客户端获取的实例列表中有可能有的实例已经不能正常服务了，客户端需要自己保证 Eureka 服务端返回的实例在不存在或不响应情况下是弹性的，最好的处理方式就是对该实例的调用设置较短超时并尝试其他服务器。 当服务端没法从其他节点获取注册信息时，....","articleStatus":0,"articlePermalink":"/articles/2017/06/29/1498726165535.html","articleImg1URL":"https://img.hacpai.com/bing/20180105.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}