{"relevantArticles":[{"articleTitle":"使用 GitBook 写文档","articleAbstractText":"最近发现很多技术书籍都放在&nbsp;GitBook&nbsp;上提供给人们阅读，刚好&nbsp;Wide&nbsp;也需要写文档，索性就尝试使用 GitBook 来做。","articleStatus":0,"articlePermalink":"/write-doc-via-gitbook","articleImg1URL":"https://img.hacpai.com/bing/20180402.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Vditor 实现 Markdown 所见即所得","articleAbstractText":"阶段性目标 大概在去年这个时候萌生了开发 Vditor 的念头，两个月后 Vditor 第一版完成。第一版基于 textarea 开发，该版本的主要目标是替换在用的第三方编辑器，实现 B3log 各产品线上编辑器的统一。 Vditor 的定位是\u201c下一代的 Markdown 编辑器，为未来而构建\u201d。第一版离这个目标相差还远，但经过这大半年的迭代我们离目标已经越来越近了： 由基于 textarea 改为基于 contenteditable 实现 Markdown 引擎 Lute，并由 markdown-it 切换为 Lute 图表渲染、多媒体播放、语音阅读等功能 所见即所得模式 所见即所得 所见即所得（What you see is what you get，缩写即 WYSIWYG）在编辑器领域指的是看到啥就是啥，比如我想加粗某个字，那\u201c加粗\u201d只是个操作，操作结果就是得到加粗后的文本，而加粗的操作（标记符）是不会出现在文本中的。 目前看来，大部分人习惯所见即所得的编辑方式，因为这种方式非常直观。但在程序员圈子里却恰恰相反，我们更喜欢标记类排版编辑方式，其中最为流行的是 Markdown......","articleStatus":0,"articlePermalink":"/articles/2019/12/26/1577370404903.html","articleImg1URL":"https://img.hacpai.com/bing/20181228.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"链滴笔记路线图","articleAbstractText":"设计原则 以文件系统为基础，不做私有格式封装 无需账号注册，可离线使用，无广告 v1 第一版主要目标是完成笔记应用基础功能，实现单机离线可用。 用户界面 分为三栏，参考有道云笔记： 文件夹 文件 编辑区 功能导航 通过 double shift 弹出功能搜索导航对话框： 配置入口 功能入口 全文搜索 不做菜单导航，所有功能入口均通过搜索导航实现。 图片/文件 使用本地绝对路径，文件由用户自己组织管理。 配置项 自动检查更新 Lute 相关设置 元数据 应用元数据保存在 ~/.liandi/conf.json ，记录已经打开的文件夹、各种配置项等 搜索索引缓存 ~/.liandi/index/ v2 第二版的主要目标是更好看的界面以及接入 B3log 分布式社区，实现分享互动。 用户界面 多主题切换，实现暗黑主题。 接入社区 作为 B3log 分布式社区的笔记端节点接入社区网络，实现文章推送和评论互动。 导出站点 支持生成导出静态站点，包含多款主题。 编辑器 实现 Typora 保留 Markdown 标记符的实时渲染模式。 架构设计 欢迎参与讨论，让我们一起来打造....","articleStatus":0,"articlePermalink":"/articles/2020/01/23/1579786655216.html","articleImg1URL":"https://img.hacpai.com/file/2020/01/%E9%93%BE%E6%BB%B4%E7%AC%94%E8%AE%B0%E6%9E%B6%E6%9E%84%E5%9B%BE-9ec13cd6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"关于所见即所得 Markdown 编辑器的讨论","articleAbstractText":"在 GitHub 上搜索 \u201cMarkdown editor\u201d，会发现几乎所有流行的 Markdown 编辑器项目都会有被人提类似这样一个特性请求： 能否像 Typora 那样进行实时渲染？ 这是一个有趣的现象，但几乎所有的项目都没实现，我翻了这些项目下面的 issue 讨论，作者们大致认为： 所见即所得违反了 Markdown 设计用意 设计上没有保证一致性，比如列表、块引用和标题就无法展开标记符；有的操作只能依赖鼠标或者快捷键，比如表格扩展行列 实现工作量较大，还有优先级更高的任务需要去做 太难了 其中 VNote 提出的\u201c折中方案\u201d，即图片、图表和公式进行实时渲染，其他元素则进行 Markdown 语法高亮。这个方案看似折中，但实则更严重地破坏了一致性，会让用户更容易分心。老外们的项目似乎很看重\u201c设计一致性\u201d，只要逻辑上有点瑕疵他们都不接受。而国人大部分（包括我）都是实用主义者，用着爽就行，管那么多干啥。 Vditor 虽然还不那么流行，但是也被提过。本来我和 @Vanessa 是想做好所见即所得就行了，这样不熟悉 Markdown 的人也能用。当我翻遍了现有 Markdo....","articleStatus":0,"articlePermalink":"/articles/2020/01/19/1579414663700.html","articleImg1URL":"https://img.hacpai.com/bing/20190803.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"CommonMark 规范要点解读","articleAbstractText":"为什么需要 Markdown 规范 CommonMark 规范开篇就提到了这个问题，并列举了十多个例子来说明制定一个 Markdown 规范的必要性。 由于没有明确的规范，Markdown 解析渲染会有很大差异。因此用户经常会发现在一个系统（例如 GitHub）上渲染正常的文档在另一个系统上渲染不正常。更糟糕的是由于 Markdown 中不存在\u201c语法错误\u201d，所以无法立即发现这类问题。 在 Markdown 处理上\u201c模糊的正确\u201d是不可取的。所以 CommonMark 规范的目的就是消除二义性，制定统一明确的 Markdown 解析渲染规则。 作者阵容 CommonMark 规范的主创 John MacFarlane（jgm）是加州大学伯克利分校的哲学教授，他在文本标记语言领域有一个很出名的项目 Pandoc（用于在各种文本标记语言之间互转格式）。他用多种编程语言实现过 Markdown 引擎，在 Markdown 处理方面他可以称得上行家中的行家。 该规范的其他参与者包括： David Greenspan, 来自 Meteor Vicent Marti, 来自 GitHub Nei.......","articleStatus":0,"articlePermalink":"/articles/2019/08/27/1566893557720.html","articleImg1URL":"https://img.hacpai.com/bing/20181218.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Lute 实现后记","articleAbstractText":"CommonMark 规范实现难点 Markdown 解析没有\u201c报错\u201d一说：无论是词法分析还是语法分析阶段，都不可能出现 error 退出。换句话说，对于编程语言而已，其在设计时就是准结构化的，甚至为了解析方便而特设语法（比如 golang 数据类型后置、模板中的表达式使用前缀表达式等），而 CM 则是为兼容各种写法、将各种写法规范化而设计的，所以规则非常多，目的是为了兼容而不是报错。 整体解析方面比较难的是计算缩进宽度。缩进在 Markdown 中主要用于缩进代码块、列表项对齐。因为列表项作为块容器是可以容纳任何元素的（包括块级元素和行级元素），所以当列表项出现子块时缩进就要根据列表的定义来计算。比如要考虑列表标记宽度，标记后到第一个非空字符的空格数等。最麻烦的是块引用嵌套列表的场景，因为块引用也是一种块容器。 除了缩进，还有个比较难的是\u201c延续\u201d判断。比如换行以后需要判断是否需要延续之前的行所在的节点。不同节点类型有不同的打断规则，最麻烦的也还是列表项和块引用，因为它们是块容器，可能出现的状态有点多。 最后还有个难点是判断列表是紧凑模式还是松散模式。因为列表是块级容器，所以需要考虑嵌....","articleStatus":0,"articlePermalink":"/articles/2019/08/29/1567062979327.html","articleImg1URL":"https://img.hacpai.com/bing/20171214.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"模板引擎实现（一）词法分析","articleAbstractText":"如果你想实现模版引擎、编译器前端、文本解析器（比如 Markdown ）或想要了解它们的实现原理，请一定不要错过本系列的文章 :grin: 模板引擎实现（一）词法分析 另外，* 本系列的文章面向的是撸起袖子就开干的朋友，所以不会介绍基础理论，比如 DFA/NFA，算法复杂度等（确切的说是没法介绍理论，因为作者能力有限 :joy:）* 在使用到的术语/定义方面作者是认真查过资料并再三斟酌的，不会出现胡编乱造，请放心理解和使用 :white_check_mark:* 本系列文章的对应项目是 freemarker.go（FreeMarker 的 golang 实现），欢迎大家关注点赞 :star2: 本文介绍了词法分析的基本概念，主要参考 golang 的 text/template/parse 包源码进行解析。 词法分析 将面向源码的字符流转成 token 流的过程是词法分析。用\u201c流\u201d来描述主要说明了处理过程是有序和连续的。比如读取源码文件时是一个字符一个字符读取的，生成的 token 也是一个接一个的。 当我们在源码中看到 scanner、lex/le....","articleStatus":0,"articlePermalink":"/articles/2017/05/31/1496233258522.html","articleImg1URL":"https://img.hacpai.com/bing/20190214.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}