{"relevantArticles":[{"articleTitle":"Markdown 解析原理详解和 Markdown AST 描述","articleAbstractText":"概述 本文主要介绍 Markdown 引擎 Lute 的整体处理流程，并详细描述了 Markdown 抽象语法树结构。 编译原理 我们通过编译原理实现了 Lute ，大致步骤是预处理、词法分析、语法分析、代码生成这几个步骤。代码结构方面我们分为两部分，解析和渲染。 1// Markdown 将 markdown 文本字节数组处理为相应的 html 字节数组。name 参数仅用于标识文本，比如可传入 id 或者标题，也可以传入 \"\"。 2func (lute *Lute) Markdown(name string, markdown []byte) (html []byte) { 3 tree := parse.Parse(name, markdown, lute.Options) 4 renderer := render.NewHtmlRenderer(tree) 5 html = renderer.Render() 6 return 7} 解析过程用于从 Markdown 原文构造抽象语法树。 1// Parse 会将 markdown 原始文本字节数组解析为一颗语法树。 2f.......","articleStatus":0,"articlePermalink":"/articles/2020/04/23/1587637426085.html","articleImg1URL":"https://img.hacpai.com/file/2020/04/devtool-d3d8a727.gif?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"链滴笔记路线图","articleAbstractText":"设计原则 以文件系统为基础，不做私有格式封装 无需账号注册，可离线使用，无广告 v1 第一版主要目标是完成笔记应用基础功能，实现单机离线可用。 用户界面 分为三栏，参考有道云笔记： 文件夹 文件 编辑区 功能导航 通过 double shift 弹出功能搜索导航对话框： 配置入口 功能入口 全文搜索 不做菜单导航，所有功能入口均通过搜索导航实现。 图片/文件 使用本地绝对路径，文件由用户自己组织管理。 配置项 自动检查更新 Lute 相关设置 元数据 应用元数据保存在 ~/.liandi/conf.json ，记录已经打开的文件夹、各种配置项等 搜索索引缓存 ~/.liandi/index/ v2 第二版的主要目标是更好看的界面以及接入 B3log 分布式社区，实现分享互动。 用户界面 多主题切换，实现暗黑主题。 接入社区 作为 B3log 分布式社区的笔记端节点接入社区网络，实现文章推送和评论互动。 导出站点 支持生成导出静态站点，包含多款主题。 编辑器 实现 Typora 保留 Markdown 标记符的实时渲染模式。 架构设计 欢迎参与讨论，让我们一起来打造....","articleStatus":0,"articlePermalink":"/articles/2020/01/23/1579786655216.html","articleImg1URL":"https://img.hacpai.com/file/2020/01/%E9%93%BE%E6%BB%B4%E7%AC%94%E8%AE%B0%E6%9E%B6%E6%9E%84%E5%9B%BE-9ec13cd6.png?imageView2/2/w/1280/format/jpg/interlace/1/q/100"},{"articleTitle":"Vditor 实现 Markdown 所见即所得","articleAbstractText":"阶段性目标 大概在去年这个时候萌生了开发 Vditor 的念头，两个月后 Vditor 第一版完成。第一版基于 textarea 开发，该版本的主要目标是替换在用的第三方编辑器，实现 B3log 各产品线上编辑器的统一。 Vditor 的定位是\u201c下一代的 Markdown 编辑器，为未来而构建\u201d。第一版离这个目标相差还远，但经过这大半年的迭代我们离目标已经越来越近了： 由基于 textarea 改为基于 contenteditable 实现 Markdown 引擎 Lute，并由 markdown-it 切换为 Lute 图表渲染、多媒体播放、语音阅读等功能 所见即所得模式 所见即所得 所见即所得（What you see is what you get，缩写即 WYSIWYG）在编辑器领域指的是看到啥就是啥，比如我想加粗某个字，那\u201c加粗\u201d只是个操作，操作结果就是得到加粗后的文本，而加粗的操作（标记符）是不会出现在文本中的。 目前看来，大部分人习惯所见即所得的编辑方式，因为这种方式非常直观。但在程序员圈子里却恰恰相反，我们更喜欢标记类排版编辑方式，其中最为流行的是 Markdown......","articleStatus":0,"articlePermalink":"/articles/2019/12/26/1577370404903.html","articleImg1URL":"https://img.hacpai.com/bing/20181228.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"CommonMark 规范要点解读","articleAbstractText":"为什么需要 Markdown 规范 CommonMark 规范开篇就提到了这个问题，并列举了十多个例子来说明制定一个 Markdown 规范的必要性。 由于没有明确的规范，Markdown 解析渲染会有很大差异。因此用户经常会发现在一个系统（例如 GitHub）上渲染正常的文档在另一个系统上渲染不正常。更糟糕的是由于 Markdown 中不存在\u201c语法错误\u201d，所以无法立即发现这类问题。 在 Markdown 处理上\u201c模糊的正确\u201d是不可取的。所以 CommonMark 规范的目的就是消除二义性，制定统一明确的 Markdown 解析渲染规则。 作者阵容 CommonMark 规范的主创 John MacFarlane（jgm）是加州大学伯克利分校的哲学教授，他在文本标记语言领域有一个很出名的项目 Pandoc（用于在各种文本标记语言之间互转格式）。他用多种编程语言实现过 Markdown 引擎，在 Markdown 处理方面他可以称得上行家中的行家。 该规范的其他参与者包括： David Greenspan, 来自 Meteor Vicent Marti, 来自 GitHub Nei.......","articleStatus":0,"articlePermalink":"/articles/2019/08/27/1566893557720.html","articleImg1URL":"https://img.hacpai.com/bing/20181218.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"使用 GitBook 写文档","articleAbstractText":"最近发现很多技术书籍都放在&nbsp;GitBook&nbsp;上提供给人们阅读，刚好&nbsp;Wide&nbsp;也需要写文档，索性就尝试使用 GitBook 来做。","articleStatus":0,"articlePermalink":"/write-doc-via-gitbook","articleImg1URL":"https://img.hacpai.com/bing/20180402.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}