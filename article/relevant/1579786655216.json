{"relevantArticles":[{"articleTitle":"Markdown 解析原理详解和 Markdown AST 描述","articleAbstractText":"概述 本文主要介绍 Markdown 引擎 Lute 的整体处理流程，并详细描述了 Markdown 抽象语法树结构。 编译原理 我们通过编译原理实现了 Lute ，大致步骤是预处理、词法分析、语法分析、代码生成这几个步骤。代码结构方面我们分为两部分，解析和渲染。 1// Markdown 将 markdown 文本字节数组处理为相应的 html 字节数组。name 参数仅用于标识文本，比如可传入 id 或者标题，也可以传入 \"\"。 2func (lute *Lute) Markdown(name string, markdown []byte) (html []byte) { 3 tree := parse.Parse(name, markdown, lute.Options) 4 renderer := render.NewHtmlRenderer(tree) 5 html = renderer.Render() 6 return 7} 解析过程用于从 Markdown 原文构造抽象语法树。 1// Parse 会将 markdown 原始文本字节数组解析为一颗语法树。 2f.......","articleStatus":0,"articlePermalink":"/articles/2020/04/23/1587637426085.html","articleImg1URL":"https://img.hacpai.com/file/2020/04/devtool-d3d8a727.gif?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"关于所见即所得 Markdown 编辑器的讨论","articleAbstractText":"在 GitHub 上搜索 \u201cMarkdown editor\u201d，会发现几乎所有流行的 Markdown 编辑器项目都会有被人提类似这样一个特性请求： 能否像 Typora 那样进行实时渲染？ 这是一个有趣的现象，但几乎所有的项目都没实现，我翻了这些项目下面的 issue 讨论，作者们大致认为： 所见即所得违反了 Markdown 设计用意 设计上没有保证一致性，比如列表、块引用和标题就无法展开标记符；有的操作只能依赖鼠标或者快捷键，比如表格扩展行列 实现工作量较大，还有优先级更高的任务需要去做 太难了 其中 VNote 提出的\u201c折中方案\u201d，即图片、图表和公式进行实时渲染，其他元素则进行 Markdown 语法高亮。这个方案看似折中，但实则更严重地破坏了一致性，会让用户更容易分心。老外们的项目似乎很看重\u201c设计一致性\u201d，只要逻辑上有点瑕疵他们都不接受。而国人大部分（包括我）都是实用主义者，用着爽就行，管那么多干啥。 Vditor 虽然还不那么流行，但是也被提过。本来我和 @Vanessa 是想做好所见即所得就行了，这样不熟悉 Markdown 的人也能用。当我翻遍了现有 Markdo....","articleStatus":0,"articlePermalink":"/articles/2020/01/19/1579414663700.html","articleImg1URL":"https://img.hacpai.com/bing/20190803.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"Vditor 实现 Markdown 所见即所得","articleAbstractText":"阶段性目标 大概在去年这个时候萌生了开发 Vditor 的念头，两个月后 Vditor 第一版完成。第一版基于 textarea 开发，该版本的主要目标是替换在用的第三方编辑器，实现 B3log 各产品线上编辑器的统一。 Vditor 的定位是\u201c下一代的 Markdown 编辑器，为未来而构建\u201d。第一版离这个目标相差还远，但经过这大半年的迭代我们离目标已经越来越近了： 由基于 textarea 改为基于 contenteditable 实现 Markdown 引擎 Lute，并由 markdown-it 切换为 Lute 图表渲染、多媒体播放、语音阅读等功能 所见即所得模式 所见即所得 所见即所得（What you see is what you get，缩写即 WYSIWYG）在编辑器领域指的是看到啥就是啥，比如我想加粗某个字，那\u201c加粗\u201d只是个操作，操作结果就是得到加粗后的文本，而加粗的操作（标记符）是不会出现在文本中的。 目前看来，大部分人习惯所见即所得的编辑方式，因为这种方式非常直观。但在程序员圈子里却恰恰相反，我们更喜欢标记类排版编辑方式，其中最为流行的是 Markdown......","articleStatus":0,"articlePermalink":"/articles/2019/12/26/1577370404903.html","articleImg1URL":"https://img.hacpai.com/bing/20181228.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"CommonMark 规范要点解读","articleAbstractText":"为什么需要 Markdown 规范 CommonMark 规范开篇就提到了这个问题，并列举了十多个例子来说明制定一个 Markdown 规范的必要性。 由于没有明确的规范，Markdown 解析渲染会有很大差异。因此用户经常会发现在一个系统（例如 GitHub）上渲染正常的文档在另一个系统上渲染不正常。更糟糕的是由于 Markdown 中不存在\u201c语法错误\u201d，所以无法立即发现这类问题。 在 Markdown 处理上\u201c模糊的正确\u201d是不可取的。所以 CommonMark 规范的目的就是消除二义性，制定统一明确的 Markdown 解析渲染规则。 作者阵容 CommonMark 规范的主创 John MacFarlane（jgm）是加州大学伯克利分校的哲学教授，他在文本标记语言领域有一个很出名的项目 Pandoc（用于在各种文本标记语言之间互转格式）。他用多种编程语言实现过 Markdown 引擎，在 Markdown 处理方面他可以称得上行家中的行家。 该规范的其他参与者包括： David Greenspan, 来自 Meteor Vicent Marti, 来自 GitHub Nei.......","articleStatus":0,"articlePermalink":"/articles/2019/08/27/1566893557720.html","articleImg1URL":"https://img.hacpai.com/bing/20181218.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"},{"articleTitle":"使用 GitBook 写文档","articleAbstractText":"最近发现很多技术书籍都放在&nbsp;GitBook&nbsp;上提供给人们阅读，刚好&nbsp;Wide&nbsp;也需要写文档，索性就尝试使用 GitBook 来做。","articleStatus":0,"articlePermalink":"/write-doc-via-gitbook","articleImg1URL":"https://img.hacpai.com/bing/20180402.jpg?imageView2/1/w/1280/h/720/interlace/1/q/100"}]}